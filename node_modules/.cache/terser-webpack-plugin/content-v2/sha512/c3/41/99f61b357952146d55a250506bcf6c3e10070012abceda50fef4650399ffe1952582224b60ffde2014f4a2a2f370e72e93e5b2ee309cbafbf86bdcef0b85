{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{83:function(t,s,a){\"use strict\";a.r(s);var e=a(1),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[a(\"h3\",{attrs:{id:\"소감\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#소감\"}},[t._v(\"#\")]),t._v(\" 소감\")]),t._v(\" \"),a(\"p\",[t._v(\"앞으로 \\\"a는 게으르게 계산된다\\\"라는 표현을 보면,\\n'a가 당장 계산되진 않고 필요할 때 계산되겠구나~' 정도로 생각하면 될 것 같다.\\n값이 필요할 때 지연 없이 값을 얻어야 하는 작업에서\\n이 계산전략을 채택하면 안 될 것 같다.\\n(어떤 필드에서 이런 일이 있을까?)\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"번역\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#번역\"}},[t._v(\"#\")]),t._v(\" 번역\")]),t._v(\" \"),a(\"p\",[t._v(\"프로그래밍 언어에서 \"),a(\"em\",[a(\"a\",{attrs:{href:\"https://en.wikipedia.org/wiki/Lazy_evaluation\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"게으른 계산\"),a(\"OutboundLink\")],1)]),t._v(\",\\n또는 \"),a(\"em\",[t._v(\"필요에 따른 호출\")]),t._v(\"은 계산 전략의 일종이다.\\n게으른 계산 전략에선 결과값이 필요할 때까지 표현식의 \"),a(\"strong\",[t._v(\"계산을 미루고\")]),t._v(\", \"),a(\"strong\",[t._v(\"반복된 계산을 피한다\")]),t._v(\".\\n\"),a(\"em\",[t._v(\"이름에 따른 호출\")]),t._v(\"같은 다른 계산 전략과 비교할 때,\\n\"),a(\"em\",[t._v(\"공유\")]),t._v(\"는 특정 함수들의  실행 시간을 지수함수단위로 줄일 수 있다.\")]),t._v(\" \"),a(\"p\",[t._v(\"게으른 계산의 이점들은 다음을 포함한다.\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"제어흐름\"),a(\"sub\",[t._v(\"control\")]),t._v(\" \"),a(\"sub\",[t._v(\"flow\")]),t._v(\"을 원시값이 아니라 추상으로서 정의할 수 있음.\")]),t._v(\" \"),a(\"li\",[t._v(\"잠재적으로 무한한 자료구조를 정의할 수 있음.\")]),t._v(\" \"),a(\"li\",[t._v(\"특정 알고리즘들을 더 간명하게 표현할 수 있음.\")]),t._v(\" \"),a(\"li\",[t._v(\"불필요한 계산과 복잡한 표현식을 계산할 때 생기는 오류 상황을 피함으로써 능률이 높아짐.\")])]),t._v(\" \"),a(\"p\",[t._v(\"게으른 계산은 종종 메모이제이션\"),a(\"sub\",[t._v(\"memoization\")]),a(\"sup\",{staticClass:\"footnote-ref\"},[a(\"a\",{attrs:{href:\"#fn1\",id:\"fnref1\"}},[t._v(\"[1]\")])]),t._v(\"과 함께 쓰인다.\\n인수에 대해 함수의 값이 계산되면, 그 결과는 인수가 인덱스인 룩업\"),a(\"sub\",[t._v(\"lookup\")]),t._v(\"표에 저장된다.\\n그 후에 함수가 호출되면, 주어진 인수에 해당하는 값이 이미 룩업표에 있는지 확인한다.\\n이미 있다면 저장된 값을 반환하고, 없다면 표에 인수를 인덱스로 그 함수값을 저장한다.\\n게으른 계산에서는 값들이 필요할 떄 만들어지기 때문에, 메모리 풋프린트\"),a(\"sup\",{staticClass:\"footnote-ref\"},[a(\"a\",{attrs:{href:\"#fn2\",id:\"fnref2\"}},[t._v(\"[2]\")])]),t._v(\"가  줄기도 한다.\\n하지만 예외처리나 입출력과 같이 반드시해야 하는 기능들\"),a(\"sup\",{staticClass:\"footnote-ref\"},[a(\"a\",{attrs:{href:\"#fn3\",id:\"fnref3\"}},[t._v(\"[3]\")])]),t._v(\"과 함께 사용하기는 어렵다.\\n왜냐하면 연산의 순서가 비결정적이기 때문이다.\\n그리고 게으른 계산은 메모리 누수를 부를 수 있다.\\n게으른 계산의 반대는 \"),a(\"em\",[t._v(\"엄격한 계산\")]),a(\"sub\",[t._v(\"strict\")]),t._v(\" \"),a(\"sub\",[t._v(\"evaluation\")]),t._v(\"으로도 알려진\\n\"),a(\"em\",[t._v(\"조급한 계산\")]),a(\"sub\",[t._v(\"eager\")]),t._v(\" \"),a(\"sub\",[t._v(\"evaluation\")]),t._v(\"이다.\\n조급한 계산은 대부분의 프로그래밍 언어가 채택하는 계산 전략이다.\")]),t._v(\" \"),a(\"hr\",{staticClass:\"footnotes-sep\"}),t._v(\" \"),a(\"section\",{staticClass:\"footnotes\"},[a(\"ol\",{staticClass:\"footnotes-list\"},[a(\"li\",{staticClass:\"footnote-item\",attrs:{id:\"fn1\"}},[a(\"p\",[t._v(\"비싼 계산에 대한 값을 캐싱하는 최적화 기법 \"),a(\"a\",{staticClass:\"footnote-backref\",attrs:{href:\"#fnref1\"}},[t._v(\"↩︎\")])])]),t._v(\" \"),a(\"li\",{staticClass:\"footnote-item\",attrs:{id:\"fn2\"}},[a(\"p\",[t._v(\"러닝 타임동안 프로그램이 사용하는 메모리량 \"),a(\"a\",{staticClass:\"footnote-backref\",attrs:{href:\"#fnref2\"}},[t._v(\"↩︎\")])])]),t._v(\" \"),a(\"li\",{staticClass:\"footnote-item\",attrs:{id:\"fn3\"}},[a(\"p\",[t._v(\"imperative features \"),a(\"a\",{staticClass:\"footnote-backref\",attrs:{href:\"#fnref3\"}},[t._v(\"↩︎\")])])])])])])}),[],!1,null,null,null);s.default=n.exports}}]);","extractedComments":[]}