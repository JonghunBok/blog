---
title: '번역; 게으른 계산이란?'
tags:
  - translation
  - wikipedia
  - lazy evaluation
categories:
  - translation
date: 2018-06-05 11:56:23
intro: 
  - 블로그 글을 읽을 때 계산을 게으르게 한다는 표현이 심심치않게 보인다.
  - 그 표현에 대한 개념을 잡기 위해 영문 위키피디아의 개요를 번역해보았다.
  - 내용 이해에 불필요한 부분은 과감히 생략하였다.
refs:
---
### 소감
앞으로 "a는 게으르게 계산된다"라는 표현을 보면, 
'a가 당장 계산되진 않고 필요할 때 계산되겠구나~' 정도로 생각하면 될 것 같다.
 값이 필요할 때 지연 없이 값을 얻어야 하는 작업에서 
이 계산전략을 채택하면 안 될 것 같다. 
(어떤 필드에서 이런 일이 있을까?)



### 번역
프로그래밍 언어에서 *[게으른 계산](https://en.wikipedia.org/wiki/Lazy_evaluation)*, 
또는 *필요에 따른 호출*은 계산 전략의 일종이다. 
게으른 계산 전략에선 결과값이 필요할 때까지 표현식의 **계산을 미루고**, **반복된 계산을 피한다**. 
*이름에 따른 호출*같은 다른 계산 전략과 비교할 때, 
*공유*는 특정 함수들의  실행 시간을 지수함수단위로 줄일 수 있다.
&nbsp;&nbsp;&nbsp;&nbsp;게으른 계산의 이점들은 다음을 포함한다.
  - 제어흐름~control~ ~flow~을 원시값이 아니라 추상으로서 정의할 수 있음.
  - 잠재적으로 무한한 자료구조를 정의할 수 있음. 
  -  특정 알고리즘들을 더 간명하게 표현할 수 있음.
  - 불필요한 계산과 복잡한 표현식을 계산할 때 생기는 오류 상황을 피함으로써 능률이 높아짐. 

&nbsp;&nbsp;&nbsp;&nbsp;게으른 계산은 종종 메모이제이션~memoization~[^memoization]과 함께 쓰인다.
인수에 대해 함수의 값이 계산되면, 그 결과는 인수가 인덱스인 룩업~lookup~표에 저장된다.
그 후에 함수가 호출되면, 주어진 인수에 해당하는 값이 이미 룩업표에 있는지 확인한다.
이미 있다면 저장된 값을 반환하고, 없다면 표에 인수를 인덱스로 그 함수값을 저장한다.
게으른 계산에서는 값들이 필요할 떄 만들어지기 때문에, 메모리 풋프린트[^footprint]가  줄기도 한다.
하지만 예외처리나 입출력과 같이 반드시해야 하는 기능들[^necessaryWork]과 함께 사용하기는 어렵다.
왜냐하면 연산의 순서가 비결정적이기 때문이다.
그리고 게으른 계산은 메모리 누수를 부를 수 있다.
게으른 계산의 반대는 *엄격한 계산*~strict~ ~evaluation~으로도 알려진 
 *조급한 계산*~eager~ ~evaluation~이다.
조급한 계산은 대부분의 프로그래밍 언어가 채택하는 계산 전략이다.




[^memoization]: 비싼 계산에 대한 값을 캐싱하는 최적화 기법
[^footprint]: 러닝 타임동안 프로그램이 사용하는 메모리량
[^necessaryWork]: imperative features 


